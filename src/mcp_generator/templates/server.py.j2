#!/usr/bin/env python3
"""{{ config.server.name }} - MCP Server
{{ config.server.description }}

Auto-generated by mcp-generator
"""

import asyncio
import json
import logging
from typing import Any, Dict, Optional
from urllib.parse import urljoin

import httpx
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Server configuration
BASE_URL = "{{ config.server.base_url }}"
TIMEOUT = {{ config.server.timeout }}
SERVER_NAME = "{{ config.server.name }}"
SERVER_VERSION = "{{ config.server.version }}"

# Authentication configuration
{% if config.server.authentication %}
AUTH_TYPE = "{{ config.server.authentication.type }}"
{% if config.server.authentication.location %}
AUTH_LOCATION = "{{ config.server.authentication.location.value }}"
{% endif %}
{% if config.server.authentication.name %}
AUTH_NAME = "{{ config.server.authentication.name }}"
{% endif %}
{% endif %}


class MCPHTTPClient:
    """HTTP client for making requests to the target API."""

    def __init__(self, base_url: str, timeout: int = 30{% if config.server.authentication %}, auth_token: Optional[str] = None{% endif %}):
        """Initialize HTTP client."""
        self.base_url = base_url
        self.timeout = timeout
        {% if config.server.authentication %}
        self.auth_token = auth_token
        {% endif %}
        self.client = httpx.AsyncClient(timeout=timeout)

    async def close(self):
        """Close HTTP client."""
        await self.client.aclose()

    def _build_headers(self, additional_headers: Optional[Dict[str, str]] = None) -> Dict[str, str]:
        """Build request headers."""
        headers = {"Content-Type": "application/json"}
        
        {% if config.server.authentication %}
        # Add authentication
        if self.auth_token:
            if AUTH_TYPE == "bearer":
                headers["Authorization"] = f"Bearer {self.auth_token}"
            {% if config.server.authentication.location and config.server.authentication.location.value == "header" and config.server.authentication.name %}
            elif AUTH_TYPE == "apikey" and AUTH_LOCATION == "header":
                headers["{{ config.server.authentication.name }}"] = self.auth_token
            {% endif %}
        {% endif %}
        
        if additional_headers:
            headers.update(additional_headers)
        
        return headers

    def _build_url(self, endpoint: str, path_params: Optional[Dict[str, Any]] = None) -> str:
        """Build request URL."""
        url = endpoint
        if path_params:
            url = url.format(**path_params)
        return urljoin(self.base_url, url.lstrip("/"))

    async def request(
        self,
        method: str,
        endpoint: str,
        path_params: Optional[Dict[str, Any]] = None,
        query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        body: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Make HTTP request."""
        url = self._build_url(endpoint, path_params)
        request_headers = self._build_headers(headers)

        {% if config.server.authentication and config.server.authentication.location and config.server.authentication.location.value == "query" and config.server.authentication.name %}
        # Add API key to query params if needed
        if self.auth_token and AUTH_TYPE == "apikey" and AUTH_LOCATION == "query":
            if query_params is None:
                query_params = {}
            query_params["{{ config.server.authentication.name }}"] = self.auth_token
        {% endif %}

        try:
            response = await self.client.request(
                method=method,
                url=url,
                params=query_params,
                headers=request_headers,
                json=body,
            )
            response.raise_for_status()
            
            # Try to parse JSON response
            try:
                return response.json()
            except json.JSONDecodeError:
                return {"text": response.text, "status_code": response.status_code}
                
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error: {e.response.status_code} - {e.response.text}")
            raise
        except Exception as e:
            logger.error(f"Request failed: {str(e)}")
            raise


# Initialize MCP server
app = Server(SERVER_NAME)
http_client: Optional[MCPHTTPClient] = None


@app.list_tools()
async def list_tools() -> list[Tool]:
    """List available tools."""
    return [
        {% for tool in config.tools %}
        Tool(
            name="{{ tool.name }}",
            description="{{ tool.description }}",
            inputSchema={
                "type": "object",
                "properties": {
                    {% for param in tool.parameters %}
                    "{{ param.name }}": {
                        "type": "{{ param.type.value }}",
                        {% if param.description %}
                        "description": "{{ param.description }}",
                        {% endif %}
                        {% if param.items_type %}
                        "items": {"type": "{{ param.items_type.value }}"},
                        {% endif %}
                    },
                    {% endfor %}
                },
                "required": [{% set req = tool.parameters | selectattr('required') | map(attribute='name') | list %}{% for n in req %}"{{ n }}"{% if not loop.last %}, {% endif %}{% endfor %}],
            },
        ),
        {% endfor %}
    ]


@app.call_tool()
async def call_tool(name: str, arguments: Any) -> list[TextContent]:
    """Handle tool calls."""
    global http_client
    
    if http_client is None:
        {% if config.server.authentication %}
        # Get auth token from environment or arguments
        import os
        auth_token = os.environ.get("API_AUTH_TOKEN")
        http_client = MCPHTTPClient(BASE_URL, TIMEOUT, auth_token)
        {% else %}
        http_client = MCPHTTPClient(BASE_URL, TIMEOUT)
        {% endif %}

    try:
        {% for tool in config.tools %}
{% if loop.first %}        if{% else %}        elif{% endif %} name == "{{ tool.name }}":
            # Extract parameters
            path_params = {}
            query_params = {}
            headers = {}
            body = {}
            
            {% for param in tool.parameters %}
            {% if param.location.value == "path" %}
            if "{{ param.name }}" in arguments:
                path_params["{{ param.name }}"] = arguments["{{ param.name }}"]
            {% elif param.location.value == "query" %}
            if "{{ param.name }}" in arguments:
                query_params["{{ param.name }}"] = arguments["{{ param.name }}"]
            {% elif param.location.value == "header" %}
            if "{{ param.name }}" in arguments:
                headers["{{ param.name }}"] = arguments["{{ param.name }}"]
            {% elif param.location.value == "body" %}
            if "{{ param.name }}" in arguments:
                body["{{ param.name }}"] = arguments["{{ param.name }}"]
            {% endif %}
            {% endfor %}
            
            # Make request
            result = await http_client.request(
                method="{{ tool.method.value }}",
                endpoint="{{ tool.endpoint }}",
                path_params=path_params or None,
                query_params=query_params or None,
                headers=headers or None,
                body=body or None,
            )
            
            return [TextContent(type="text", text=json.dumps(result, indent=2))]
        {% endfor %}
        else:
            raise ValueError(f"Unknown tool: {name}")
            
    except Exception as e:
        logger.error(f"Tool execution failed: {str(e)}")
        return [TextContent(type="text", text=f"Error: {str(e)}")]


async def main():
    """Run the MCP server."""
    global http_client
    
    logger.info(f"Starting {SERVER_NAME} v{SERVER_VERSION}")
    logger.info(f"Target API: {BASE_URL}")
    
    try:
        async with stdio_server() as (read_stream, write_stream):
            await app.run(read_stream, write_stream, app.create_initialization_options())
    finally:
        if http_client:
            await http_client.close()


if __name__ == "__main__":
    asyncio.run(main())
